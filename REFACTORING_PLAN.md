# План рефакторинга проекта AnalogProcess

Этот документ описывает предлагаемые улучшения в кодовой базе проекта с целью повышения ее качества, поддерживаемости и производительности.

## High Priority

### 1. Устранение дублирования в `DevelopmentSetupViewModel`

- **Проблема:** Существуют два очень похожих ViewModel (`DevelopmentSetupViewModel` и `SwiftDataDevelopmentSetupViewModel`) для работы с параметрами проявки. Один использует `Codable` модели для работы с сетевыми данными, а другой — `SwiftData` модели. Это приводит к большому количеству дублирования кода и усложняет внесение изменений.
- **Цель:** Создать единую, абстрактную систему, которая бы не дублировала логику.
- **Пошаговый план:**
    1.  **Создать протокол:** Определить общий протокол, например `DevelopmentParametersProtocol`, который будут реализовывать обе модели (`DevelopmentParameters` и `SwiftDataDevelopmentParameters`). Этот протокол должен описывать общие свойства (`film`, `developer`, `iso`, `time` и т.д.).
    2.  **Обобщить ViewModel:** Рефакторинг `DevelopmentSetupViewModel` для работы с этим протоколом. Это сделает ViewModel независимым от конкретного типа модели. Можно использовать дженерики: `class DevelopmentSetupViewModel<T: DevelopmentParametersProtocol>`.
    3.  **Удалить дубликат:** Удалить `SwiftDataDevelopmentSetupViewModel` и использовать обновленный `DevelopmentSetupViewModel` в обоих контекстах.
    4.  **Адаптировать View:** Внести минимальные изменения в `DevelopmentSetupView` для работы с обновленным ViewModel.

## Medium Priority

### 2. Оптимизация синхронизации SwiftData

- **Проблема:** `SwiftDataService` при синхронизации удаляет все существующие данные и заменяет их новыми. Это неэффективно и может приводить к проблемам с производительностью на больших объемах данных.
- **Цель:** Реализовать "умную" синхронизацию, которая будет вносить только необходимые изменения.
- **Пошаговый план:**
    1.  **Получить данные:** В `syncDataFromGitHub` получить новые данные из сети.
    2.  **Сравнить данные:** Для каждого типа данных (Film, Developer и т.д.) сравнить список новых объектов со списком существующих в базе данных.
    3.  **Определить изменения:** Сформировать три списка: объекты для добавления (новые), объекты для обновления (изменившиеся) и объекты для удаления (отсутствующие в новых данных).
    4.  **Применить изменения:** Выполнить только необходимые операции (insert, update, delete) в `ModelContext`.

### 3. Внедрение зависимостей (Dependency Injection)

- **Проблема:** Сервисы, такие как `SwiftDataService` и `GitHubDataService`, используются как синглтоны (`.shared`), что создает сильную связанность между компонентами и усложняет написание юнит-тестов.
- **Цель:** Уменьшить связанность кода, используя внедрение зависимостей.
- **Пошаговый план:**
    1.  **Обновить инициализаторы:** Изменить инициализаторы сервисов (`AutoSyncService`, `SwiftDataService` и др.), чтобы они принимали свои зависимости (например, `NetworkSessionProtocol`, `ModelContext`) в качестве параметров.
    2.  **Создать контейнер зависимостей:** Создать центральное место (например, отдельный класс или в `AnalogProcessApp`), где будут создаваться и настраиваться все сервисы.
    3.  **Внедрять зависимости:** Передавать экземпляры сервисов в `ViewModel` и другие объекты через их инициализаторы, вместо использования `.shared`.

## Low Priority

### 4. Обобщение логики обновления SwiftData

- **Проблема:** В `SwiftDataService` методы `updateFilms`, `updateDevelopers` и т.д. содержат практически идентичный код.
- **Цель:** Создать универсальную функцию для обновления данных.
- **Пошаговый план:**
    1.  **Создать дженерик-функцию:** Написать обобщенную функцию, например `func update<M: PersistentModel, D: Decodable>(items: [D], modelContext: ModelContext)`, которая будет принимать массив `Decodable` объектов и обновлять соответствующие `PersistentModel` объекты в SwiftData.
    2.  **Использовать функцию:** Заменить повторяющийся код в `SwiftDataService` вызовами этой новой функции.

### 5. Вынесение конфигурации во внешний файл

- **Проблема:** URL репозитория GitHub жестко закодирован в `ProcessConstants.githubRepoURL`.
- **Цель:** Сделать конфигурацию более гибкой.
- **Пошаговый план:**
    1.  **Использовать `.env`:** В проекте уже есть файл `.env`. Можно добавить туда URL репозитория.
    2.  **Чтение конфигурации:** Написать механизм для чтения этого значения при старте приложения.
    3.  **Внедрение конфигурации:** Передавать это значение в `GitHubDataService` через его инициализатор (связано с задачей по внедрению зависимостей).
